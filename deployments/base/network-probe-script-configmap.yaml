apiVersion: v1
data:
  network_probe.py: "#!/usr/bin/env python3\n\"\"\"\nDedicated Network Probe Exporter\nContinuously
    measures ICMP ping and TCP handshake latency (RAW DATA ONLY)\nExports raw latency
    measurements via Prometheus for consumption by flow_manager\nFlow manager is responsible
    for all jitter calculations and control decisions\n\"\"\"\n\nimport socket\nimport
    time\nimport logging\nimport os\nimport struct\nfrom dataclasses import dataclass\nfrom
    typing import Optional, List\nfrom prometheus_client import start_http_server,
    Gauge, Histogram\n\n# Configuration\nROBOT_CONTROL_HOST = os.getenv(\"ROBOT_CONTROL_HOST\",
    \"robot-control-svc.default.svc.cluster.local\")\nROBOT_CONTROL_UDP_PORT = int(os.getenv(\"ROBOT_CONTROL_UDP_PORT\",
    \"5201\"))  # UDP reflector\nSAFETY_SCANNER_HOST = os.getenv(\"SAFETY_SCANNER_HOST\",
    \"safety-scanner-svc.default.svc.cluster.local\")\nSAFETY_SCANNER_TCP_PORT = int(os.getenv(\"SAFETY_SCANNER_TCP_PORT\",
    \"5202\"))  # TCP service\nPROBE_INTERVAL = float(os.getenv(\"PROBE_INTERVAL\",
    \"0.5\"))\nMETRICS_PORT = int(os.getenv(\"METRICS_PORT\", \"9090\"))\n\n# Logging\nlogging.basicConfig(\n
    \   level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s'\n)\nlogger
    = logging.getLogger(__name__)\n\n# Prometheus Metrics - RAW MEASUREMENTS ONLY\ntcp_latency_gauge
    = Gauge('network_probe_tcp_latency_ms', 'TCP handshake latency in milliseconds',
    ['target'])\ntcp_success_gauge = Gauge('network_probe_tcp_success', 'TCP probe
    success (1=success, 0=failure)', ['target'])\ntcp_throughput_gauge = Gauge('network_probe_tcp_throughput_mbps',
    'TCP throughput in Mbps', ['target'])\n\nudp_latency_gauge = Gauge('network_probe_udp_latency_ms',
    'UDP round-trip latency in milliseconds', ['target'])\nudp_success_gauge = Gauge('network_probe_udp_success',
    'UDP probe success (1=success, 0=failure)', ['target'])\n\nicmp_latency_gauge
    = Gauge('network_probe_icmp_latency_ms', 'ICMP ping latency in milliseconds',
    ['target'])\nicmp_success_gauge = Gauge('network_probe_icmp_success', 'ICMP probe
    success (1=success, 0=failure)', ['target'])\n\n# Histogram for distribution analysis\ntcp_latency_hist
    = Histogram('network_probe_tcp_latency_hist', 'TCP latency histogram', ['target'],
    \n                              buckets=[0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0,
    100.0])\nudp_latency_hist = Histogram('network_probe_udp_latency_hist', 'UDP latency
    histogram', ['target'],\n                              buckets=[0.5, 1.0, 2.0,
    5.0, 10.0, 20.0, 50.0, 100.0])\nicmp_latency_hist = Histogram('network_probe_icmp_latency_hist',
    'ICMP latency histogram', ['target'],\n                               buckets=[0.1,
    0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0])\n\n\n@dataclass\nclass ProbeResult:\n    \"\"\"Single
    probe measurement result\"\"\"\n    latency_ms: Optional[float]\n    success:
    bool\n    timestamp: float\n\n\nclass NetworkProbe:\n    \"\"\"Measures TCP handshake,
    UDP RTT, and TCP throughput - RAW DATA ONLY\"\"\"\n    \n    def __init__(self,
    robot_control_host: str, robot_control_udp_port: int,\n                 safety_scanner_host:
    str, safety_scanner_tcp_port: int):\n        # Robot control (UDP)\n        self.robot_control_host
    = robot_control_host\n        self.robot_control_udp_port = robot_control_udp_port\n
    \       \n        # Safety scanner (TCP)\n        self.safety_scanner_host = safety_scanner_host\n
    \       self.safety_scanner_tcp_port = safety_scanner_tcp_port\n        \n        #
    Resolve targets\n        try:\n            self.robot_control_ip = socket.gethostbyname(robot_control_host)\n
    \           logger.info(f\"Resolved robot-control: {robot_control_host} -> {self.robot_control_ip}\")\n
    \       except Exception as e:\n            logger.error(f\"Failed to resolve
    {robot_control_host}: {e}\")\n            self.robot_control_ip = robot_control_host\n
    \       \n        try:\n            self.safety_scanner_ip = socket.gethostbyname(safety_scanner_host)\n
    \           logger.info(f\"Resolved safety-scanner: {safety_scanner_host} -> {self.safety_scanner_ip}\")\n
    \       except Exception as e:\n            logger.error(f\"Failed to resolve
    {safety_scanner_host}: {e}\")\n            self.safety_scanner_ip = safety_scanner_host\n
    \       \n        # Try to create raw ICMP socket (needs CAP_NET_RAW)\n        self.icmp_enabled
    = self._check_icmp_capability()\n    \n    def _check_icmp_capability(self) ->
    bool:\n        \"\"\"Check if we have capability to send raw ICMP packets\"\"\"\n
    \       try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW,
    socket.IPPROTO_ICMP)\n            sock.close()\n            logger.info(\"Raw
    ICMP socket capability available\")\n            return True\n        except PermissionError:\n
    \           logger.warning(\"WARNING: No CAP_NET_RAW - ICMP probing disabled (use
    TCP only)\")\n            return False\n        except Exception as e:\n            logger.error(f\"ICMP
    capability check failed: {e}\")\n            return False\n    \n    def measure_tcp_handshake(self)
    -> ProbeResult:\n        \"\"\"Measure TCP 3-way handshake latency to safety-scanner\"\"\"\n
    \       start = time.perf_counter()\n        try:\n            sock = socket.socket(socket.AF_INET,
    socket.SOCK_STREAM)\n            sock.settimeout(1.0)\n            sock.connect((self.safety_scanner_ip,
    self.safety_scanner_tcp_port))\n            latency_ms = (time.perf_counter()
    - start) * 1000\n            sock.close()\n            return ProbeResult(latency_ms=latency_ms,
    success=True, timestamp=time.time())\n        except (socket.timeout, ConnectionRefusedError,
    OSError) as e:\n            latency_ms = (time.perf_counter() - start) * 1000\n
    \           logger.debug(f\"TCP probe failed: {e} (took {latency_ms:.2f}ms)\")\n
    \           return ProbeResult(latency_ms=None, success=False, timestamp=time.time())\n
    \   \n    def measure_icmp_ping(self) -> ProbeResult:\n        \"\"\"Measure ICMP
    echo request/reply RTT using raw socket\"\"\"\n        if not self.icmp_enabled:\n
    \           return ProbeResult(latency_ms=None, success=False, timestamp=time.time())\n
    \       \n        try:\n            # Create raw ICMP socket\n            sock
    = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n            sock.settimeout(1.0)\n
    \           \n            # Build ICMP Echo Request packet\n            icmp_id
    = os.getpid() & 0xFFFF\n            icmp_seq = 1\n            \n            #
    ICMP header: type=8 (echo request), code=0, checksum=0 (placeholder), id, seq\n
    \           header = self._create_icmp_packet(icmp_id, icmp_seq)\n            \n
    \           start = time.perf_counter()\n            sock.sendto(header, (self.target_ip,
    0))\n            \n            # Wait for echo reply\n            sock.recvfrom(1024)
    \ # ICMP Echo Reply\n            latency_ms = (time.perf_counter() - start) *
    1000\n            \n            sock.close()\n            return ProbeResult(latency_ms=latency_ms,
    success=True, timestamp=time.time())\n            \n        except socket.timeout:\n
    \           latency_ms = (time.perf_counter() - start) * 1000\n            logger.debug(f\"ICMP
    probe timeout (took {latency_ms:.2f}ms)\")\n            return ProbeResult(latency_ms=None,
    success=False, timestamp=time.time())\n        except Exception as e:\n            logger.debug(f\"ICMP
    probe error: {e}\")\n            return ProbeResult(latency_ms=None, success=False,
    timestamp=time.time())\n    \n    def measure_udp_rtt(self, count: int = 10) ->
    ProbeResult:\n        \"\"\"Measure UDP round-trip time to robot-control reflector\"\"\"\n
    \       try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n
    \           sock.settimeout(0.2)  # 200ms timeout per probe\n            \n            latencies
    = []\n            for _ in range(count):\n                # Send timestamped packet\n
    \               send_time = time.perf_counter()\n                payload = struct.pack('d',
    send_time)\n                sock.sendto(payload, (self.robot_control_ip, self.robot_control_udp_port))\n
    \               \n                try:\n                    data, _ = sock.recvfrom(1024)\n
    \                   recv_time = time.perf_counter()\n                    latency_ms
    = (recv_time - send_time) * 1000\n                    latencies.append(latency_ms)\n
    \               except socket.timeout:\n                    logger.debug(f\"UDP
    probe timeout\")\n                    continue\n            \n            sock.close()\n
    \           \n            if latencies:\n                avg_latency = sum(latencies)
    / len(latencies)\n                return ProbeResult(latency_ms=avg_latency, success=True,
    timestamp=time.time())\n            else:\n                return ProbeResult(latency_ms=None,
    success=False, timestamp=time.time())\n                \n        except Exception
    as e:\n            logger.error(f\"UDP probe error: {e}\")\n            return
    ProbeResult(latency_ms=None, success=False, timestamp=time.time())\n    \n    def
    measure_tcp_throughput(self, duration_sec: float = 0.5) -> float:\n        \"\"\"Estimate
    TCP throughput by sending data for duration\"\"\"\n        try:\n            sock
    = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(2.0)\n
    \           sock.connect((self.safety_scanner_ip, self.safety_scanner_tcp_port))\n
    \           \n            # Send data as fast as possible for duration\n            payload
    = b'X' * 1024  # 1KB payload\n            bytes_sent = 0\n            start_time
    = time.perf_counter()\n            \n            while (time.perf_counter() -
    start_time) < duration_sec:\n                sent = sock.send(payload)\n                bytes_sent
    += sent\n            \n            elapsed = time.perf_counter() - start_time\n
    \           sock.close()\n            \n            # Calculate throughput in
    Mbps\n            throughput_mbps = (bytes_sent * 8) / (elapsed * 1_000_000)\n
    \           return throughput_mbps\n            \n        except Exception as
    e:\n            logger.debug(f\"TCP throughput measurement failed: {e}\")\n            return
    0.0\n    \n    def _create_icmp_packet(self, icmp_id: int, icmp_seq: int) -> bytes:\n
    \       \"\"\"Create ICMP Echo Request packet with checksum\"\"\"\n        # ICMP
    header: type(8), code(8), checksum(16), id(16), seq(16)\n        icmp_type = 8
    \ # Echo Request\n        icmp_code = 0\n        checksum = 0\n        \n        #
    Pack header without checksum\n        header = bytearray([icmp_type, icmp_code,
    0, 0, (icmp_id >> 8) & 0xFF, icmp_id & 0xFF, \n                           (icmp_seq
    >> 8) & 0xFF, icmp_seq & 0xFF])\n        \n        # Calculate checksum\n        checksum
    = self._calculate_checksum(header)\n        header[2] = (checksum >> 8) & 0xFF\n
    \       header[3] = checksum & 0xFF\n        \n        return bytes(header)\n
    \   \n    def _calculate_checksum(self, data: bytearray) -> int:\n        \"\"\"Calculate
    Internet checksum (RFC 1071)\"\"\"\n        checksum = 0\n        for i in range(0,
    len(data), 2):\n            word = (data[i] << 8) + (data[i+1] if i+1 < len(data)
    else 0)\n            checksum += word\n        \n        # Add carry and fold
    to 16 bits\n        checksum = (checksum >> 16) + (checksum & 0xFFFF)\n        checksum
    += (checksum >> 16)\n        return ~checksum & 0xFFFF\n    \n    \n    def run_probe_cycle(self):\n
    \       \"\"\"Run one complete probe cycle and update metrics - RAW DATA ONLY\"\"\"\n
    \       # Measure UDP to robot-control\n        udp_result = self.measure_udp_rtt(count=10)\n
    \       udp_success_gauge.labels(target=self.robot_control_host).set(1 if udp_result.success
    else 0)\n        \n        if udp_result.success and udp_result.latency_ms is
    not None:\n            udp_latency_gauge.labels(target=self.robot_control_host).set(udp_result.latency_ms)\n
    \           udp_latency_hist.labels(target=self.robot_control_host).observe(udp_result.latency_ms)\n
    \           logger.debug(f\"UDP RTT (robot-control): {udp_result.latency_ms:.2f}ms\")\n
    \       \n        # Measure TCP to safety-scanner\n        tcp_result = self.measure_tcp_handshake()\n
    \       tcp_success_gauge.labels(target=self.safety_scanner_host).set(1 if tcp_result.success
    else 0)\n        \n        if tcp_result.success and tcp_result.latency_ms is
    not None:\n            tcp_latency_gauge.labels(target=self.safety_scanner_host).set(tcp_result.latency_ms)\n
    \           tcp_latency_hist.labels(target=self.safety_scanner_host).observe(tcp_result.latency_ms)\n
    \           logger.debug(f\"TCP handshake (safety-scanner): {tcp_result.latency_ms:.2f}ms\")\n
    \       \n        # Measure TCP throughput to safety-scanner (every 5th cycle
    to reduce overhead)\n        if not hasattr(self, '_throughput_counter'):\n            self._throughput_counter
    = 0\n        self._throughput_counter += 1\n        \n        if self._throughput_counter
    >= 5:\n            throughput = self.measure_tcp_throughput(duration_sec=0.5)\n
    \           tcp_throughput_gauge.labels(target=self.safety_scanner_host).set(throughput)\n
    \           logger.debug(f\"TCP throughput (safety-scanner): {throughput:.2f}
    Mbps\")\n            self._throughput_counter = 0\n            self._throughput_counter
    = 0\n\n\nif __name__ == \"__main__\":\n    main()\n    \"\"\"Main loop: start
    metrics server and run probes continuously\"\"\"\n    logger.info(\"=\" * 60)\n
    \   logger.info(\"Network Probe Exporter Starting\")\n    logger.info(\"=\" *
    60)\n    logger.info(f\"Robot Control: {ROBOT_CONTROL_HOST}:{ROBOT_CONTROL_UDP_PORT}
    (UDP)\")\n    logger.info(f\"Safety Scanner: {SAFETY_SCANNER_HOST}:{SAFETY_SCANNER_TCP_PORT}
    (TCP)\")\n    logger.info(f\"Probe Interval: {PROBE_INTERVAL}s\")\n    logger.info(f\"Metrics
    Port: {METRICS_PORT}\")\n    logger.info(\"=\" * 60)\n    \n    # Start Prometheus
    metrics server\n    start_http_server(METRICS_PORT)\n    logger.info(f\"Metrics
    server listening on :{METRICS_PORT}/metrics\")\n    \n    # Initialize probe\n
    \   probe = NetworkProbe(ROBOT_CONTROL_HOST, ROBOT_CONTROL_UDP_PORT,\n                        SAFETY_SCANNER_HOST,
    SAFETY_SCANNER_TCP_PORT)\n    \n    # Main loop\n    cycle = 0\n    try:\n        while
    True:\n            cycle += 1\n            logger.debug(f\"--- Probe Cycle {cycle}
    ---\")\n            \n            probe.run_probe_cycle()\n            \n            time.sleep(PROBE_INTERVAL)\n
    \           \n    except KeyboardInterrupt:\n        logger.info(\"\\nShutting
    down probe exporter\")\n    except Exception as e:\n        logger.error(f\"Fatal
    error: {e}\", exc_info=True)\n        raise\n\n\nif __name__ == \"__main__\":\n
    \   main()\n\n\nclass UDPJitterProbe:\n    \"\"\"\n    UDP Jitter Measurement
    using IQR (Inter-Quartile Range)\n    Sends timestamped packets to UDP reflector
    and measures round-trip latency\n    \"\"\"\n    \n    def __init__(self, target_ip:
    str, port: int = 5201):\n        \"\"\"\n        Initialize UDP jitter probe\n
    \       \n        Args:\n            target_ip: IP address or hostname of UDP
    reflector\n            port: UDP port number (default: 5201)\n        \"\"\"\n
    \       self.target_ip = target_ip\n        self.port = port\n        self.timeout
    = 0.2  # 200ms timeout\n    \n    def measure_jitter(self, count: int = 50) ->
    float:\n        \"\"\"\n        Measure jitter using IQR method (Q3 - Q1)\n        \n
    \       Args:\n            count: Number of probe packets to send (default: 50)\n
    \       \n        Returns:\n            Jitter value in milliseconds (IQR calculation)\n
    \       \"\"\"\n        latencies = []\n        \n        for _ in range(count):\n
    \           try:\n                # Create UDP socket with timeout\n                sock
    = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                sock.settimeout(self.timeout)\n
    \               \n                # Pack current timestamp into binary payload\n
    \               send_time = time.time()\n                payload = struct.pack('d',
    send_time)\n                \n                # Send timestamped packet to reflector\n
    \               sock.sendto(payload, (self.target_ip, self.port))\n                \n
    \               # Wait for echo response\n                data, _ = sock.recvfrom(1024)\n
    \               recv_time = time.time()\n                \n                # Unpack
    original timestamp and calculate RTT\n                original_time = struct.unpack('d',
    data)[0]\n                rtt_ms = (recv_time - original_time) * 1000\n                \n
    \               latencies.append(rtt_ms)\n                sock.close()\n                \n
    \           except socket.timeout:\n                # Skip timeouts - don't count
    as valid measurement\n                pass\n            except Exception as e:\n
    \               # Log error but continue with other measurements\n                pass\n
    \       \n        # Calculate IQR jitter\n        if len(latencies) < 4:\n            #
    Not enough samples for reliable IQR calculation\n            return 0.0\n        \n
    \       # Sort latencies for percentile calculation\n        sorted_latencies
    = sorted(latencies)\n        n = len(sorted_latencies)\n        \n        # Calculate
    Q1 (25th percentile) and Q3 (75th percentile)\n        q1_index = n // 4\n        q3_index
    = (3 * n) // 4\n        \n        q1 = sorted_latencies[q1_index]\n        q3
    = sorted_latencies[q3_index]\n        \n        # IQR = Q3 - Q1\n        iqr =
    q3 - q1\n        \n        return round(iqr, 2)\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: network-probe-script
  namespace: default
