---
# Flow Manager Metrics Exporter - Exposes all dashboard metrics
apiVersion: v1
kind: ConfigMap
metadata:
  name: bandwidth-exporter-script
  namespace: kube-system
data:
  bandwidth_exporter.py: |
    #!/usr/bin/env python3
    """
    Flow Manager Metrics Exporter for Prometheus
    Exposes bandwidth limits AND real-time SLA metrics:
      - kubernetes_deployment_bandwidth_limit_mbps (from K8s annotations)
      - flowmanager_udp_jitter_ms (active UDP probe to robot-control)
      - flowmanager_tcp_throughput_mbps (TCP probe to safety-scanner)
      - flowmanager_best_effort_throughput_mbps (estimated from bandwidth limit)
    """

    import os
    import time
    import socket
    import threading
    from collections import deque
    from kubernetes import client, config
    from prometheus_client import start_http_server, Gauge, Info
    import logging

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - [MetricsExporter] %(message)s'
    )
    logger = logging.getLogger(__name__)

    # Configuration
    ROBOT_CONTROL_HOST = os.getenv('ROBOT_CONTROL_HOST', 'robot-control-svc.default.svc.cluster.local')
    ROBOT_CONTROL_PORT = int(os.getenv('ROBOT_CONTROL_PORT', '5201'))
    SAFETY_SCANNER_HOST = os.getenv('SAFETY_SCANNER_HOST', 'safety-scanner-svc.default.svc.cluster.local')
    SAFETY_SCANNER_PORT = int(os.getenv('SAFETY_SCANNER_PORT', '5202'))
    PROBE_INTERVAL = float(os.getenv('PROBE_INTERVAL', '1.0'))
    WINDOW_SIZE = int(os.getenv('WINDOW_SIZE', '20'))

    # Prometheus metrics
    bandwidth_limit = Gauge(
        'kubernetes_deployment_bandwidth_limit_mbps',
        'Current egress bandwidth limit in Mbps',
        ['namespace', 'deployment']
    )
    udp_jitter_gauge = Gauge(
        'flowmanager_udp_jitter_ms',
        'UDP jitter to critical service (IQR-based)',
        ['service', 'target_host']
    )
    udp_latency_gauge = Gauge(
        'flowmanager_udp_latency_ms',
        'UDP probe latency to critical service',
        ['service', 'target_host']
    )
    tcp_throughput_gauge = Gauge(
        'flowmanager_tcp_throughput_mbps',
        'Estimated TCP throughput to critical service',
        ['service', 'target_host']
    )
    tcp_latency_gauge = Gauge(
        'flowmanager_tcp_latency_ms',
        'TCP connection latency to critical service',
        ['service', 'target_host']
    )
    best_effort_throughput_gauge = Gauge(
        'flowmanager_best_effort_throughput_mbps',
        'Estimated actual throughput of best-effort traffic',
        ['deployment']
    )
    controller_info = Info(
        'flowmanager_controller',
        'Flow Manager controller configuration'
    )

    class UDPProbe:
        UDP_PROBE_MSG = b'METRICS_PROBE'
        
        def __init__(self, host, port, window_size=20):
            self.host = host
            self.port = port
            self.latency_history = deque(maxlen=window_size)
            self._resolved_ip = None
            
        def _resolve_host(self):
            if self._resolved_ip:
                return self._resolved_ip
            try:
                self._resolved_ip = socket.gethostbyname(self.host)
                return self._resolved_ip
            except socket.gaierror as e:
                logger.warning(f"DNS resolution failed for {self.host}: {e}")
                return None
        
        def _calc_iqr_jitter(self):
            if len(self.latency_history) < 4:
                return 0.0
            sorted_samples = sorted(self.latency_history)
            n = len(sorted_samples)
            q1 = sorted_samples[n // 4]
            q3 = sorted_samples[(3 * n) // 4]
            return q3 - q1

        def measure(self):
            target_ip = self._resolve_host()
            if not target_ip:
                return {'latency_ms': 100.0, 'jitter_ms': 50.0, 'status': 'dns_failure'}
            
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(1.0)
                start = time.perf_counter()
                sock.sendto(self.UDP_PROBE_MSG, (target_ip, self.port))
                end = time.perf_counter()
                sock.close()
                
                latency_ms = (end - start) * 1000
                self.latency_history.append(latency_ms)
                return {'latency_ms': latency_ms, 'jitter_ms': self._calc_iqr_jitter(), 'status': 'ok'}
            except socket.timeout:
                self.latency_history.append(100.0)
                return {'latency_ms': 100.0, 'jitter_ms': self._calc_iqr_jitter(), 'status': 'timeout'}
            except Exception as e:
                return {'latency_ms': 0.0, 'jitter_ms': 0.0, 'status': 'error'}

    class TCPProbe:
        def __init__(self, host, port, window_size=20):
            self.host = host
            self.port = port
            self.latency_history = deque(maxlen=window_size)
            self.success_count = 0
            self.total_count = 0
            
        def _calc_iqr_jitter(self):
            if len(self.latency_history) < 4:
                return 0.0
            sorted_samples = sorted(self.latency_history)
            n = len(sorted_samples)
            q1 = sorted_samples[n // 4]
            q3 = sorted_samples[(3 * n) // 4]
            return q3 - q1

        def measure(self):
            self.total_count += 1
            try:
                start = time.perf_counter()
                sock = socket.create_connection((self.host, self.port), timeout=2.0)
                sock.close()
                end = time.perf_counter()
                
                latency_ms = (end - start) * 1000
                self.latency_history.append(latency_ms)
                self.success_count += 1
                
                success_rate = self.success_count / max(self.total_count, 1)
                latency_factor = max(0.1, 1.0 - (latency_ms / 100.0))
                estimated_throughput = 100.0 * success_rate * latency_factor
                
                return {'latency_ms': latency_ms, 'throughput_mbps': estimated_throughput, 'status': 'ok'}
            except socket.timeout:
                self.latency_history.append(100.0)
                return {'latency_ms': 100.0, 'throughput_mbps': 0.0, 'status': 'timeout'}
            except Exception:
                return {'latency_ms': 0.0, 'throughput_mbps': 0.0, 'status': 'error'}

    class MetricsCollector:
        def __init__(self):
            try:
                config.load_incluster_config()
                logger.info("Loaded in-cluster Kubernetes config")
            except config.ConfigException:
                config.load_kube_config()
                logger.info("Loaded local Kubernetes config")
            
            self.v1 = client.AppsV1Api()
            self.udp_probe = UDPProbe(ROBOT_CONTROL_HOST, ROBOT_CONTROL_PORT, WINDOW_SIZE)
            self.tcp_probe = TCPProbe(SAFETY_SCANNER_HOST, SAFETY_SCANNER_PORT, WINDOW_SIZE)
            
            controller_info.info({
                'robot_control_host': ROBOT_CONTROL_HOST,
                'robot_control_port': str(ROBOT_CONTROL_PORT),
                'safety_scanner_host': SAFETY_SCANNER_HOST,
                'safety_scanner_port': str(SAFETY_SCANNER_PORT),
                'version': '2.0'
            })
            
        def collect_bandwidth_limits(self):
            try:
                deployments = self.v1.list_namespaced_deployment(namespace='default')
                for dep in deployments.items:
                    if dep.spec.template.metadata.annotations:
                        bw_annotation = dep.spec.template.metadata.annotations.get('kubernetes.io/egress-bandwidth')
                        if bw_annotation:
                            bw_mbps = int(bw_annotation.rstrip('MmKkGg'))
                            bandwidth_limit.labels(
                                namespace=dep.metadata.namespace,
                                deployment=dep.metadata.name
                            ).set(bw_mbps)
                            
                            if 'telemetry' in dep.metadata.name or 'erp' in dep.metadata.name:
                                best_effort_throughput_gauge.labels(
                                    deployment=dep.metadata.name
                                ).set(min(bw_mbps * 0.8, bw_mbps))
            except Exception as e:
                logger.error(f"Error collecting bandwidth metrics: {e}")

        def collect_probe_metrics(self):
            udp_result = self.udp_probe.measure()
            if udp_result['status'] in ['ok', 'timeout']:
                udp_jitter_gauge.labels(service='robot-control', target_host=ROBOT_CONTROL_HOST).set(udp_result['jitter_ms'])
                udp_latency_gauge.labels(service='robot-control', target_host=ROBOT_CONTROL_HOST).set(udp_result['latency_ms'])
            
            tcp_result = self.tcp_probe.measure()
            if tcp_result['status'] in ['ok', 'timeout']:
                tcp_throughput_gauge.labels(service='safety-scanner', target_host=SAFETY_SCANNER_HOST).set(tcp_result['throughput_mbps'])
                tcp_latency_gauge.labels(service='safety-scanner', target_host=SAFETY_SCANNER_HOST).set(tcp_result['latency_ms'])

        def run_collection_loop(self):
            while True:
                try:
                    self.collect_bandwidth_limits()
                    self.collect_probe_metrics()
                except Exception as e:
                    logger.error(f"Collection error: {e}")
                time.sleep(PROBE_INTERVAL)

    def main():
        logger.info("=" * 60)
        logger.info("Flow Manager Metrics Exporter Starting")
        logger.info(f"  Robot Control: {ROBOT_CONTROL_HOST}:{ROBOT_CONTROL_PORT}")
        logger.info(f"  Safety Scanner: {SAFETY_SCANNER_HOST}:{SAFETY_SCANNER_PORT}")
        logger.info("=" * 60)
        
        start_http_server(8000)
        logger.info("Prometheus metrics server started on port 8000")
        
        collector = MetricsCollector()
        collector.run_collection_loop()

    if __name__ == '__main__':
        main()

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: bandwidth-exporter
  namespace: kube-system
  labels:
    app: bandwidth-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: bandwidth-exporter
  template:
    metadata:
      labels:
        app: bandwidth-exporter
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
    spec:
      serviceAccountName: ml-controller-sa
      containers:
      - name: exporter
        image: python:3.11-slim
        command: ["/bin/sh", "-c"]
        args:
        - |
          pip install --no-cache-dir kubernetes prometheus-client
          python /app/bandwidth_exporter.py
        ports:
        - containerPort: 8000
          name: metrics
        volumeMounts:
        - name: script-volume
          mountPath: /app
      volumes:
      - name: script-volume
        configMap:
          name: bandwidth-exporter-script

---
apiVersion: v1
kind: Service
metadata:
  name: bandwidth-exporter
  namespace: kube-system
  labels:
    app: bandwidth-exporter
spec:
  type: ClusterIP
  ports:
  - port: 8000
    targetPort: 8000
    name: metrics
  selector:
    app: bandwidth-exporter
