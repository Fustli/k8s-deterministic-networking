apiVersion: v1
kind: ConfigMap
metadata:
  name: ml-controller-script
  namespace: kube-system
data:
  requirements.txt: |
    kubernetes
    prometheus-api-client
  ml_controller.py: |
    #!/usr/bin/env python3

    import os
    import time
    import kubernetes
    from kubernetes import client, config
    from prometheus_api_client import PrometheusConnect

    # Initialize Kubernetes configuration
    try:
        config.load_incluster_config()  # We're running inside a pod
    except config.ConfigException:
        config.load_kube_config()       # We're running locally

    # Initialize the Kubernetes API client
    v1_apps = client.AppsV1Api()
    deployment_name = "telemetry-upload-deployment"
    namespace = "default"

    # Initialize Prometheus client
    PROMETHEUS_URL = os.getenv('PROMETHEUS_URL', 'http://prometheus-server:9090')
    prom = PrometheusConnect(url=PROMETHEUS_URL, disable_ssl=True)

    def get_critical_app_latency():
        """
        Query Prometheus/Hubble for the UDP jitter of the robot-control application.
        Returns the 95th percentile jitter in milliseconds.
        """
        try:
            # PromQL query for Hubble metrics
            query = """
            histogram_quantile(0.95, sum(
                rate(hubble_flow_latency_seconds_bucket{
                    source_pod=~"robot-control.*",
                    protocol="UDP"
                }[1m]
            ) by (le))
            """
            result = prom.custom_query(query)
            
            if result and len(result) > 0:
                # Convert seconds to milliseconds
                latency_ms = float(result[0]['value'][1]) * 1000
                return latency_ms
            else:
                return 0.5  # Default fallback value
        except Exception as e:
            print(f"Error querying Prometheus: {e}")
            return 0.5  # Default fallback value if query fails

    def adjust_bandwidth(current_jitter):
        """
        Implements a simple control loop to adjust bandwidth based on observed jitter.
        Returns bandwidth limit in Mbps.
        """
        TARGET_JITTER = 1.0  # Target jitter threshold in ms
        MIN_BANDWIDTH = 10   # Minimum bandwidth in Mbps
        MAX_BANDWIDTH = 1000 # Maximum bandwidth in Mbps
        
        # Simple proportional control
        if current_jitter > TARGET_JITTER:
            # Reduce bandwidth if jitter is too high
            return max(MIN_BANDWIDTH, current_bandwidth - 50)
        else:
            # Increase bandwidth if jitter is under control
            return min(MAX_BANDWIDTH, current_bandwidth + 10)

    def update_deployment_bandwidth(bandwidth_mbps):
        """
        Updates the deployment's annotation to set egress bandwidth limit.
        """
        try:
            # Get current deployment
            deployment = v1_apps.read_namespaced_deployment(
                name=deployment_name,
                namespace=namespace
            )
            
            # Prepare the bandwidth annotation
            bandwidth_value = f"{bandwidth_mbps}M"
            
            # Update deployment template annotations
            if deployment.spec.template.metadata is None:
                deployment.spec.template.metadata = client.V1ObjectMeta()
            
            if deployment.spec.template.metadata.annotations is None:
                deployment.spec.template.metadata.annotations = {}
            
            deployment.spec.template.metadata.annotations[
                "kubernetes.io/egress-bandwidth"
            ] = bandwidth_value
            
            # Patch the deployment
            v1_apps.patch_namespaced_deployment(
                name=deployment_name,
                namespace=namespace,
                body=deployment
            )
            
            print(f"Successfully updated bandwidth limit to {bandwidth_value}")
            return True
            
        except Exception as e:
            print(f"Error updating deployment: {e}")
            return False

    # Main control loop
    current_bandwidth = 100  # Starting bandwidth in Mbps

    def main():
        global current_bandwidth
        
        print("ML Controller starting...")
        while True:
            try:
                # Get current jitter from Prometheus/Hubble
                current_jitter = get_critical_app_latency()
                print(f"Current jitter: {current_jitter:.2f}ms")
                
                # Calculate new bandwidth limit
                new_bandwidth = adjust_bandwidth(current_jitter)
                
                # Only update if bandwidth changed significantly
                if abs(new_bandwidth - current_bandwidth) >= 5:
                    if update_deployment_bandwidth(new_bandwidth):
                        current_bandwidth = new_bandwidth
                
                # Sleep for control interval
                time.sleep(5)  # Adjust as needed
                
            except Exception as e:
                print(f"Error in main loop: {e}")
                time.sleep(5)  # Wait before retrying

    if __name__ == "__main__":
        main()