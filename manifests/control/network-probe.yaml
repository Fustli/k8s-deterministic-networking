---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: network-probe
  namespace: default

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: network-probe
  namespace: default
  labels:
    app: network-probe
spec:
  replicas: 1
  selector:
    matchLabels:
      app: network-probe
  template:
    metadata:
      labels:
        app: network-probe
    spec:
      serviceAccountName: network-probe
      # Deploy on master node for consistent network path
      nodeSelector:
        kubernetes.io/hostname: kube-master
      tolerations:
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      containers:
      - name: probe
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          pip install --no-cache-dir prometheus-client && \
          python /app/network_probe.py
        env:
        - name: TARGET_HOST
          value: "safety-scanner-svc.default.svc.cluster.local"
        - name: TCP_PORT
          value: "5202"
        - name: PROBE_INTERVAL
          value: "0.5"
        - name: METRICS_PORT
          value: "9090"
        volumeMounts:
        - name: probe-script
          mountPath: /app
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        # Need CAP_NET_RAW for ICMP ping
        securityContext:
          capabilities:
            add:
            - NET_RAW
      volumes:
      - name: probe-script
        configMap:
          name: network-probe-script

---
apiVersion: v1
kind: Service
metadata:
  name: network-probe-svc
  namespace: default
  labels:
    app: network-probe
spec:
  selector:
    app: network-probe
  ports:
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP
  type: ClusterIP

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: network-probe-script
  namespace: default
data:
  network_probe.py: |
    #!/usr/bin/env python3
    """
    Dedicated Network Probe Exporter
    Continuously measures ICMP ping and TCP handshake latency/jitter
    Exports metrics via Prometheus for consumption by flow_manager
    """

    import socket
    import time
    import logging
    import os
    import statistics
    from dataclasses import dataclass
    from typing import List, Optional
    from collections import deque
    from prometheus_client import start_http_server, Gauge, Histogram

    # Configuration
    TARGET_HOST = os.getenv("TARGET_HOST", "robot-control-svc.default.svc.cluster.local")
    TCP_PORT = int(os.getenv("TCP_PORT", "5202"))
    PROBE_INTERVAL = float(os.getenv("PROBE_INTERVAL", "0.5"))
    METRICS_PORT = int(os.getenv("METRICS_PORT", "9090"))
    HISTORY_SIZE = 20

    # Logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s'
    )
    logger = logging.getLogger(__name__)

    # Prometheus Metrics
    tcp_latency_gauge = Gauge('network_probe_tcp_latency_ms', 'TCP handshake latency in milliseconds', ['target'])
    tcp_jitter_gauge = Gauge('network_probe_tcp_jitter_ms', 'TCP handshake jitter (IQR) in milliseconds', ['target'])
    tcp_success_gauge = Gauge('network_probe_tcp_success', 'TCP probe success (1=success, 0=failure)', ['target'])

    icmp_latency_gauge = Gauge('network_probe_icmp_latency_ms', 'ICMP ping latency in milliseconds', ['target'])
    icmp_jitter_gauge = Gauge('network_probe_icmp_jitter_ms', 'ICMP ping jitter (IQR) in milliseconds', ['target'])
    icmp_success_gauge = Gauge('network_probe_icmp_success', 'ICMP probe success (1=success, 0=failure)', ['target'])

    combined_jitter_gauge = Gauge('network_probe_combined_jitter_ms', 'Combined jitter metric used for control', ['target'])

    # Histogram for distribution analysis
    tcp_latency_hist = Histogram('network_probe_tcp_latency_hist', 'TCP latency histogram', ['target'], 
                                  buckets=[0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0, 100.0])
    icmp_latency_hist = Histogram('network_probe_icmp_latency_hist', 'ICMP latency histogram', ['target'],
                                   buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0])


    @dataclass
    class ProbeResult:
        """Single probe measurement result"""
        latency_ms: Optional[float]
        success: bool
        timestamp: float


    class NetworkProbe:
        """Measures TCP and ICMP latency with jitter calculation"""
        
        def __init__(self, target_host: str, tcp_port: int):
            self.target_host = target_host
            self.tcp_port = tcp_port
            
            # Resolve target once at startup
            try:
                self.target_ip = socket.gethostbyname(target_host)
                logger.info(f"Resolved {target_host} -> {self.target_ip}")
            except Exception as e:
                logger.error(f"Failed to resolve {target_host}: {e}")
                self.target_ip = target_host
            
            # Rolling window for jitter calculation
            self.tcp_history: deque = deque(maxlen=HISTORY_SIZE)
            self.icmp_history: deque = deque(maxlen=HISTORY_SIZE)
            
            # Try to create raw ICMP socket (needs CAP_NET_RAW)
            self.icmp_enabled = self._check_icmp_capability()
        
        def _check_icmp_capability(self) -> bool:
            """Check if we have capability to send raw ICMP packets"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
                sock.close()
                logger.info("Raw ICMP socket capability available")
                return True
            except PermissionError:
                logger.warning("WARNING: No CAP_NET_RAW - ICMP probing disabled (use TCP only)")
                return False
            except Exception as e:
                logger.error(f"ICMP capability check failed: {e}")
                return False
        
        def measure_tcp_handshake(self) -> ProbeResult:
            """Measure TCP 3-way handshake latency"""
            start = time.perf_counter()
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1.0)
                sock.connect((self.target_ip, self.tcp_port))
                latency_ms = (time.perf_counter() - start) * 1000
                sock.close()
                return ProbeResult(latency_ms=latency_ms, success=True, timestamp=time.time())
            except (socket.timeout, ConnectionRefusedError, OSError) as e:
                latency_ms = (time.perf_counter() - start) * 1000
                logger.debug(f"TCP probe failed: {e} (took {latency_ms:.2f}ms)")
                return ProbeResult(latency_ms=None, success=False, timestamp=time.time())
        
        def measure_icmp_ping(self) -> ProbeResult:
            """Measure ICMP echo request/reply RTT using raw socket"""
            if not self.icmp_enabled:
                return ProbeResult(latency_ms=None, success=False, timestamp=time.time())
            
            try:
                # Create raw ICMP socket
                sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
                sock.settimeout(1.0)
                
                # Build ICMP Echo Request packet
                icmp_id = os.getpid() & 0xFFFF
                icmp_seq = 1
                
                # ICMP header: type=8 (echo request), code=0, checksum=0 (placeholder), id, seq
                header = self._create_icmp_packet(icmp_id, icmp_seq)
                
                start = time.perf_counter()
                sock.sendto(header, (self.target_ip, 0))
                
                # Wait for echo reply
                sock.recvfrom(1024)  # ICMP Echo Reply
                latency_ms = (time.perf_counter() - start) * 1000
                
                sock.close()
                return ProbeResult(latency_ms=latency_ms, success=True, timestamp=time.time())
                
            except socket.timeout:
                latency_ms = (time.perf_counter() - start) * 1000
                logger.debug(f"ICMP probe timeout (took {latency_ms:.2f}ms)")
                return ProbeResult(latency_ms=None, success=False, timestamp=time.time())
            except Exception as e:
                logger.debug(f"ICMP probe error: {e}")
                return ProbeResult(latency_ms=None, success=False, timestamp=time.time())
        
        def _create_icmp_packet(self, icmp_id: int, icmp_seq: int) -> bytes:
            """Create ICMP Echo Request packet with checksum"""
            # ICMP header: type(8), code(8), checksum(16), id(16), seq(16)
            icmp_type = 8  # Echo Request
            icmp_code = 0
            checksum = 0
            
            # Pack header without checksum
            header = bytearray([icmp_type, icmp_code, 0, 0, (icmp_id >> 8) & 0xFF, icmp_id & 0xFF, 
                               (icmp_seq >> 8) & 0xFF, icmp_seq & 0xFF])
            
            # Calculate checksum
            checksum = self._calculate_checksum(header)
            header[2] = (checksum >> 8) & 0xFF
            header[3] = checksum & 0xFF
            
            return bytes(header)
        
        def _calculate_checksum(self, data: bytearray) -> int:
            """Calculate Internet checksum (RFC 1071)"""
            checksum = 0
            for i in range(0, len(data), 2):
                word = (data[i] << 8) + (data[i+1] if i+1 < len(data) else 0)
                checksum += word
            
            # Add carry and fold to 16 bits
            checksum = (checksum >> 16) + (checksum & 0xFFFF)
            checksum += (checksum >> 16)
            return ~checksum & 0xFFFF
        
        def calculate_jitter_iqr(self, history: deque) -> Optional[float]:
            """Calculate jitter using Interquartile Range (IQR)"""
            if len(history) < 4:
                return None
            
            sorted_latencies = sorted(history)
            n = len(sorted_latencies)
            q1_idx = n // 4
            q3_idx = 3 * n // 4
            
            q1 = sorted_latencies[q1_idx]
            q3 = sorted_latencies[q3_idx]
            iqr = q3 - q1
            
            return iqr
        
        def run_probe_cycle(self):
            """Run one complete probe cycle and update metrics"""
            # Measure TCP
            tcp_result = self.measure_tcp_handshake()
            tcp_success_gauge.labels(target=self.target_host).set(1 if tcp_result.success else 0)
            
            if tcp_result.success and tcp_result.latency_ms is not None:
                self.tcp_history.append(tcp_result.latency_ms)
                tcp_latency_gauge.labels(target=self.target_host).set(tcp_result.latency_ms)
                tcp_latency_hist.labels(target=self.target_host).observe(tcp_result.latency_ms)
                logger.debug(f"TCP latency: {tcp_result.latency_ms:.2f}ms")
            
            # Measure ICMP (if enabled)
            icmp_result = self.measure_icmp_ping()
            icmp_success_gauge.labels(target=self.target_host).set(1 if icmp_result.success else 0)
            
            if icmp_result.success and icmp_result.latency_ms is not None:
                self.icmp_history.append(icmp_result.latency_ms)
                icmp_latency_gauge.labels(target=self.target_host).set(icmp_result.latency_ms)
                icmp_latency_hist.labels(target=self.target_host).observe(icmp_result.latency_ms)
                logger.debug(f"ICMP latency: {icmp_result.latency_ms:.2f}ms")
            
            # Calculate jitter
            tcp_jitter = self.calculate_jitter_iqr(self.tcp_history)
            if tcp_jitter is not None:
                tcp_jitter_gauge.labels(target=self.target_host).set(tcp_jitter)
            
            icmp_jitter = self.calculate_jitter_iqr(self.icmp_history)
            if icmp_jitter is not None:
                icmp_jitter_gauge.labels(target=self.target_host).set(icmp_jitter)
            
            # Combined jitter for control decisions (use best available)
            combined_jitter = None
            if self.icmp_enabled and icmp_jitter is not None:
                combined_jitter = icmp_jitter  # ICMP preferred (lower overhead)
            elif tcp_jitter is not None:
                combined_jitter = tcp_jitter  # Fallback to TCP
            
            if combined_jitter is not None:
                combined_jitter_gauge.labels(target=self.target_host).set(combined_jitter)
                tcp_str = f"{tcp_jitter:.3f}" if tcp_jitter else "N/A"
                icmp_str = f"{icmp_jitter:.3f}" if icmp_jitter else "N/A"
                logger.info(f"Jitter: TCP={tcp_str}ms, ICMP={icmp_str}ms, Combined={combined_jitter:.3f}ms")
            else:
                logger.warning("No jitter data available yet (need more samples)")


    def main():
        """Main loop: start metrics server and run probes continuously"""
        logger.info("=" * 60)
        logger.info("Network Probe Exporter Starting")
        logger.info("=" * 60)
        logger.info(f"Target: {TARGET_HOST}")
        logger.info(f"TCP Port: {TCP_PORT}")
        logger.info(f"Probe Interval: {PROBE_INTERVAL}s")
        logger.info(f"Metrics Port: {METRICS_PORT}")
        logger.info("=" * 60)
        
        # Start Prometheus metrics server
        start_http_server(METRICS_PORT)
        logger.info(f"Metrics server listening on :{METRICS_PORT}/metrics")
        
        # Initialize probe
        probe = NetworkProbe(TARGET_HOST, TCP_PORT)
        
        # Main loop
        cycle = 0
        try:
            while True:
                cycle += 1
                logger.debug(f"--- Probe Cycle {cycle} ---")
                
                probe.run_probe_cycle()
                
                time.sleep(PROBE_INTERVAL)
                
        except KeyboardInterrupt:
            logger.info("\nShutting down probe exporter")
        except Exception as e:
            logger.error(f"Fatal error: {e}", exc_info=True)
            raise


    if __name__ == "__main__":
        main()
