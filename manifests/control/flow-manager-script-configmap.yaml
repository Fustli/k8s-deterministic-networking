apiVersion: v1
data:
  config_loader.py: "#!/usr/bin/env python3\n\"\"\"\nCritical Application SLA Configuration
    Loader\nParses critical-apps.yaml and provides config to flow_manager\n\"\"\"\n\nimport
    yaml\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List,
    Optional\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass CriticalAppConfig:\n
    \   \"\"\"Configuration for a single critical application\"\"\"\n    name: str\n
    \   service: str\n    port: int\n    protocol: str\n    max_jitter_ms: float\n
    \   max_latency_ms: Optional[float]\n    priority: int\n\n\n@dataclass\nclass
    BestEffortTarget:\n    \"\"\"Best-effort deployment to throttle\"\"\"\n    deployment:
    str\n    namespace: str\n    initial_bandwidth: int\n\n\n@dataclass\nclass ControlConfig:\n
    \   \"\"\"Global control parameters\"\"\"\n    probe_interval: float\n    control_interval:
    float\n    window_size: int\n    step_down: int\n    step_up: int\n    min_bandwidth:
    int\n    max_bandwidth: int\n\n\n@dataclass\nclass SystemConfig:\n    \"\"\"Complete
    system configuration\"\"\"\n    control: ControlConfig\n    critical_apps: List[CriticalAppConfig]\n
    \   best_effort_targets: List[BestEffortTarget]\n    aggregation_method: str\n
    \   severity_multiplier_enabled: bool\n    severity_max_multiplier: float\n\n\nclass
    ConfigLoader:\n    \"\"\"Loads and validates critical-apps.yaml configuration\"\"\"\n
    \   \n    @staticmethod\n    def load(config_path: str = \"/etc/flowmanager/critical-apps.yaml\")
    -> SystemConfig:\n        \"\"\"Load configuration from YAML file\"\"\"\n        try:\n
    \           with open(config_path, 'r') as f:\n                config = yaml.safe_load(f)\n
    \           \n            logger.info(f\"Loaded configuration from {config_path}\")\n
    \           return ConfigLoader._parse_config(config)\n            \n        except
    FileNotFoundError:\n            logger.error(f\"Config file not found: {config_path}\")\n
    \           raise\n        except yaml.YAMLError as e:\n            logger.error(f\"YAML
    parsing error: {e}\")\n            raise\n    \n    @staticmethod\n    def _parse_config(config:
    dict) -> SystemConfig:\n        \"\"\"Parse and validate configuration dictionary\"\"\"\n
    \       \n        # Parse control parameters\n        ctrl = config['control']\n
    \       control_config = ControlConfig(\n            probe_interval=float(ctrl['probe_interval']),\n
    \           control_interval=float(ctrl['control_interval']),\n            window_size=int(ctrl['window_size']),\n
    \           step_down=int(ctrl['step_down']),\n            step_up=int(ctrl['step_up']),\n
    \           min_bandwidth=int(ctrl['min_bandwidth']),\n            max_bandwidth=int(ctrl['max_bandwidth'])\n
    \       )\n        \n        # Parse critical applications\n        critical_apps
    = []\n        for app in config['critical_apps']:\n            critical_apps.append(CriticalAppConfig(\n
    \               name=app['name'],\n                service=app['service'],\n                port=int(app['port']),\n
    \               protocol=app['protocol'],\n                max_jitter_ms=float(app['max_jitter_ms']),\n
    \               max_latency_ms=app.get('max_latency_ms'),\n                priority=int(app['priority'])\n
    \           ))\n        \n        # Sort by priority (highest first)\n        critical_apps.sort(key=lambda
    x: x.priority, reverse=True)\n        \n        # Parse best-effort targets\n
    \       best_effort = []\n        for target in config['best_effort_targets']:\n
    \           best_effort.append(BestEffortTarget(\n                deployment=target['deployment'],\n
    \               namespace=target['namespace'],\n                initial_bandwidth=int(target['initial_bandwidth'])\n
    \           ))\n        \n        # Parse aggregation settings (optional, use
    defaults if not provided)\n        severity_enabled = config.get('severity_multiplier_enabled',
    True)\n        severity_max = config.get('severity_max_multiplier', 5.0)\n        \n
    \       return SystemConfig(\n            control=control_config,\n            critical_apps=critical_apps,\n
    \           best_effort_targets=best_effort,\n            aggregation_method='priority',
    \ # Always use priority-based\n            severity_multiplier_enabled=severity_enabled,\n
    \           severity_max_multiplier=float(severity_max)\n        )\n    \n    @staticmethod\n
    \   def validate(config: SystemConfig) -> bool:\n        \"\"\"Validate configuration
    consistency\"\"\"\n        \n        # Check at least one critical app defined\n
    \       if not config.critical_apps:\n            logger.error(\"No critical applications
    defined\")\n            return False\n        \n        # Check at least one best-effort
    target\n        if not config.best_effort_targets:\n            logger.error(\"No
    best-effort targets defined\")\n            return False\n        \n        #
    Validate bandwidth ranges\n        if config.control.min_bandwidth >= config.control.max_bandwidth:\n
    \           logger.error(\"min_bandwidth must be < max_bandwidth\")\n            return
    False\n        \n        # Validate protocols\n        valid_protocols = ['TCP',
    'UDP']\n        for app in config.critical_apps:\n            if app.protocol
    not in valid_protocols:\n                logger.error(f\"Invalid protocol {app.protocol}
    for {app.name}\")\n                return False\n        \n        logger.info(\"Configuration
    validation passed\")\n        return True\n"
  flow_manager.py: "#!/usr/bin/env python3\n\"\"\"\nProduction-Grade Deterministic
    Networking Flow Manager for Kubernetes\nVersion: 5.0 (Multi-App Config-Driven
    Mode)\n\nMonitors multiple critical applications defined in critical-apps.yaml\nCalculates
    jitter from network-probe raw latency measurements\nMakes control decisions based
    on SLA violations\nDynamically patches best-effort deployment annotations\n\"\"\"\n\nimport
    os\nimport sys\nimport time\nimport logging\nimport requests\nfrom typing import
    Dict, Optional, Tuple\nfrom collections import deque\nfrom kubernetes import client,
    config as k8s_config\n\n# Import config loader\nsys.path.insert(0, '/app')\nfrom
    config_loader import ConfigLoader, SystemConfig, CriticalAppConfig\n\nlogging.basicConfig(\n
    \   level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - [%(name)s]
    %(message)s'\n)\nlogger = logging.getLogger(\"FlowManager\")\n\n\nclass MetricsClient:\n
    \   \"\"\"Fetches raw latency measurements from network-probe service\"\"\"\n
    \   \n    def __init__(self, probe_service: str, window_size: int):\n        self.probe_url
    = f\"http://{probe_service}/metrics\"\n        self.windows = {}  # Per-app rolling
    windows\n        self.window_size = window_size\n        logger.info(f\"MetricsClient
    initialized: probe={probe_service}, window_size={window_size}\")\n    \n    def
    fetch_and_calculate_jitter(self, app: CriticalAppConfig) -> Optional[Tuple[float,
    float]]:\n        \"\"\"\n        Fetch raw latency for app and calculate jitter
    locally\n        Returns: (latency_ms, jitter_ms) or None on failure\n        \"\"\"\n
    \       try:\n            response = requests.get(self.probe_url, timeout=2.0)\n
    \           response.raise_for_status()\n            \n            # Parse Prometheus
    text format - look for tcp or udp latency\n            metric_name = f'network_probe_{app.protocol.lower()}_latency_ms'\n
    \           \n            latency = None\n            for line in response.text.split('\\n'):\n
    \               if line.startswith(metric_name + '{'):\n                    latency
    = float(line.split()[-1])\n                    break\n            \n            if
    latency is None:\n                logger.debug(f\"No latency metric found for
    {app.name} ({app.protocol})\")\n                return None\n            \n            #
    Initialize window if first measurement\n            if app.name not in self.windows:\n
    \               self.windows[app.name] = deque(maxlen=self.window_size)\n            \n
    \           # Add to rolling window\n            self.windows[app.name].append(latency)\n
    \           \n            # Calculate jitter (IQR method)\n            if len(self.windows[app.name])
    >= 5:\n                jitter = self._calculate_jitter_iqr(self.windows[app.name])\n
    \               return (latency, jitter)\n            else:\n                #
    Not enough samples yet\n                return (latency, 0.0)\n            \n
    \       except requests.RequestException as e:\n            logger.error(f\"Failed
    to fetch metrics for {app.name}: {e}\")\n            return None\n        except
    Exception as e:\n            logger.error(f\"Error processing metrics for {app.name}:
    {e}\")\n            return None\n    \n    def _calculate_jitter_iqr(self, window:
    deque) -> float:\n        \"\"\"Calculate jitter using Interquartile Range (robust
    to outliers)\"\"\"\n        if len(window) < 5:\n            return 0.0\n        \n
    \       sorted_samples = sorted(window)\n        n = len(sorted_samples)\n        \n
    \       q1_idx = n // 4\n        q3_idx = (3 * n) // 4\n        \n        q1 =
    sorted_samples[q1_idx]\n        q3 = sorted_samples[q3_idx]\n        \n        iqr
    = q3 - q1\n        return round(iqr, 3)\n\n\nclass BandwidthController:\n    \"\"\"\n
    \   Multi-Application Bandwidth Controller\n    Monitors all critical apps and
    throttles best-effort deployments\n    \"\"\"\n    \n    def __init__(self, config:
    SystemConfig):\n        self.config = config\n        self.metrics_client = MetricsClient(\n
    \           probe_service=os.getenv('PROBE_SERVICE', 'network-probe-svc.default.svc.cluster.local:9090'),\n
    \           window_size=config.control.window_size\n        )\n        \n        #
    Initialize Kubernetes client\n        try:\n            k8s_config.load_incluster_config()\n
    \           logger.info(\"Loaded in-cluster Kubernetes config\")\n        except:\n
    \           k8s_config.load_kube_config()\n            logger.info(\"Loaded local
    kubeconfig\")\n        \n        self.apps_v1 = client.AppsV1Api()\n        \n
    \       # Current bandwidth state (per best-effort deployment)\n        self.current_bandwidths
    = {}\n        for target in config.best_effort_targets:\n            bw = self._get_current_bandwidth(target.deployment,
    target.namespace)\n            self.current_bandwidths[target.deployment] = bw
    if bw else target.initial_bandwidth\n        \n        logger.info(f\"Controller
    initialized with {len(config.critical_apps)} critical apps\")\n        logger.info(f\"Initial
    bandwidths: {self.current_bandwidths}\")\n    \n    def _get_current_bandwidth(self,
    deployment: str, namespace: str) -> Optional[int]:\n        \"\"\"Read current
    bandwidth annotation from deployment\"\"\"\n        try:\n            dep = self.apps_v1.read_namespaced_deployment(deployment,
    namespace)\n            annotations = dep.spec.template.metadata.annotations or
    {}\n            bw_str = annotations.get('kubernetes.io/egress-bandwidth', '0M')\n
    \           return int(bw_str.replace('M', '').replace('m', '').replace('G', '000').replace('g',
    '000'))\n        except Exception as e:\n            logger.warning(f\"Failed
    to read bandwidth for {deployment}: {e}\")\n            return None\n    \n    def
    control_loop(self):\n        \"\"\"Main control loop - monitors all critical apps
    and adjusts bandwidth\"\"\"\n        cycle = 0\n        \n        logger.info(\"=\"*60)\n
    \       logger.info(\"Starting Multi-App Bandwidth Controller\")\n        logger.info(f\"Monitoring
    {len(self.config.critical_apps)} critical applications:\")\n        for app in
    self.config.critical_apps:\n            logger.info(f\"  - {app.name}: max_jitter={app.max_jitter_ms}ms,
    priority={app.priority}\")\n        logger.info(f\"Best-effort targets: {[t.deployment
    for t in self.config.best_effort_targets]}\")\n        logger.info(\"=\"*60)\n
    \       \n        while True:\n            cycle += 1\n            logger.info(f\"\\n---
    Cycle {cycle} ---\")\n            \n            # Step 1: Measure all critical
    apps\n            app_states = {}\n            for app in self.config.critical_apps:\n
    \               result = self.metrics_client.fetch_and_calculate_jitter(app)\n
    \               if result:\n                    latency, jitter = result\n                    violation
    = jitter > app.max_jitter_ms\n                    severity = jitter / app.max_jitter_ms
    if violation else 0.0\n                    \n                    app_states[app.name]
    = {\n                        'app': app,\n                        'latency': latency,\n
    \                       'jitter': jitter,\n                        'violation':
    violation,\n                        'severity': severity\n                    }\n
    \                   \n                    status = \"VIOLATION\" if violation
    else \"OK\"\n                    logger.info(f\"  {app.name}: latency={latency:.2f}ms,
    jitter={jitter:.3f}ms \"\n                               f\"(threshold={app.max_jitter_ms}ms)
    [{status}]\")\n            \n            if not app_states:\n                logger.warning(\"No
    app measurements available, skipping cycle\")\n                time.sleep(self.config.control.control_interval)\n
    \               continue\n            \n            # Step 2: Aggregate violations
    (use highest priority app's state)\n            decision = self._make_control_decision(app_states)\n
    \           \n            # Step 3: Apply bandwidth adjustments\n            self._apply_bandwidth_changes(decision)\n
    \           \n            time.sleep(self.config.control.control_interval)\n    \n
    \   def _make_control_decision(self, app_states: Dict) -> Dict:\n        \"\"\"\n
    \       Decide bandwidth adjustment based on aggregated app states\n        Returns:
    {'action': 'throttle'|'release'|'maintain', 'reason': str, 'multiplier': float}\n
    \       \"\"\"\n        \n        # Find worst violation (highest priority app
    that violates SLA)\n        worst_violation = None\n        for state in app_states.values():\n
    \           if state['violation']:\n                if worst_violation is None
    or state['app'].priority > worst_violation['app'].priority:\n                    worst_violation
    = state\n        \n        if worst_violation:\n            # Calculate severity
    multiplier\n            multiplier = 1.0\n            if self.config.severity_multiplier_enabled:\n
    \               multiplier = min(\n                    worst_violation['severity'],\n
    \                   self.config.severity_max_multiplier\n                )\n            \n
    \           return {\n                'action': 'throttle',\n                'reason':
    f\"{worst_violation['app'].name} jitter {worst_violation['jitter']:.3f}ms > {worst_violation['app'].max_jitter_ms}ms\",\n
    \               'multiplier': multiplier\n            }\n        \n        # Check
    if all apps are performing well (jitter < 50% of threshold)\n        all_good
    = all(\n            state['jitter'] < (state['app'].max_jitter_ms * 0.5)\n            for
    state in app_states.values()\n        )\n        \n        if all_good:\n            return
    {\n                'action': 'release',\n                'reason': 'All critical
    apps below 50% jitter threshold',\n                'multiplier': 1.0\n            }\n
    \       \n        return {\n            'action': 'maintain',\n            'reason':
    'Apps within acceptable range',\n            'multiplier': 1.0\n        }\n    \n
    \   def _apply_bandwidth_changes(self, decision: Dict):\n        \"\"\"Apply bandwidth
    changes to all best-effort deployments\"\"\"\n        \n        action = decision['action']\n
    \       reason = decision['reason']\n        multiplier = decision['multiplier']\n
    \       \n        logger.info(f\"Decision: {action.upper()} - {reason}\")\n        \n
    \       if action == 'maintain':\n            logger.info(f\"Bandwidth maintained:
    {self.current_bandwidths}\")\n            return\n        \n        for target
    in self.config.best_effort_targets:\n            current_bw = self.current_bandwidths[target.deployment]\n
    \           \n            if action == 'throttle':\n                step = int(self.config.control.step_down
    * multiplier)\n                new_bw = max(self.config.control.min_bandwidth,
    current_bw - step)\n                \n            elif action == 'release':\n
    \               new_bw = min(self.config.control.max_bandwidth, \n                           current_bw
    + self.config.control.step_up)\n            \n            if new_bw != current_bw:\n
    \               success = self._patch_deployment_bandwidth(\n                    target.deployment,\n
    \                   target.namespace,\n                    new_bw\n                )\n
    \               \n                if success:\n                    delta = new_bw
    - current_bw\n                    logger.info(f\"  {target.deployment}: {current_bw}M
    -> {new_bw}M ({delta:+d}M)\")\n                    self.current_bandwidths[target.deployment]
    = new_bw\n            else:\n                logger.info(f\"  {target.deployment}:
    At limit ({new_bw}M)\")\n    \n    def _patch_deployment_bandwidth(self, deployment:
    str, namespace: str, bandwidth_mbps: int) -> bool:\n        \"\"\"Patch deployment
    annotation to set egress bandwidth\"\"\"\n        try:\n            patch_body
    = {\n                \"spec\": {\n                    \"template\": {\n                        \"metadata\":
    {\n                            \"annotations\": {\n                                \"kubernetes.io/egress-bandwidth\":
    f\"{bandwidth_mbps}M\"\n                            }\n                        }\n
    \                   }\n                }\n            }\n            \n            self.apps_v1.patch_namespaced_deployment(\n
    \               name=deployment,\n                namespace=namespace,\n                body=patch_body\n
    \           )\n            return True\n            \n        except Exception
    as e:\n            logger.error(f\"Failed to patch {deployment}: {e}\")\n            return
    False\n\n\ndef main():\n    \"\"\"Entry point\"\"\"\n    config_path = os.getenv('CONFIG_PATH',
    '/etc/flowmanager/critical-apps.yaml')\n    \n    try:\n        # Load configuration\n
    \       config = ConfigLoader.load(config_path)\n        \n        if not ConfigLoader.validate(config):\n
    \           logger.error(\"Configuration validation failed\")\n            sys.exit(1)\n
    \       \n        logger.info(f\"Loaded configuration for {len(config.critical_apps)}
    critical apps:\")\n        for app in config.critical_apps:\n            logger.info(f\"
    \ - {app.name}: max_jitter={app.max_jitter_ms}ms (priority={app.priority})\")\n
    \       \n        # Start controller\n        controller = BandwidthController(config)\n
    \       controller.control_loop()\n        \n    except KeyboardInterrupt:\n        logger.info(\"\\nShutting
    down controller\")\n    except Exception as e:\n        logger.error(f\"Controller
    startup failed: {e}\", exc_info=True)\n        sys.exit(1)\n\n\nif __name__ ==
    \"__main__\":\n    main()\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: flow-manager-script
  namespace: kube-system
